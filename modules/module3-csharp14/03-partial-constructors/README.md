# Feature 3: Partial Constructors

## Run It

```powershell
dotnet run -f net10.0
```

## The Business Problem

Meijer's inventory system needs to create thousands of `InventoryItem` objects from multiple sources:

- **From Database**: EF Core materializes items with properties directly
- **From JSON APIs**: External suppliers send product data that gets deserialized
- **From Source Generators**: Code-gen tools create initialization logic at compile time
- **From Manual Code**: Developers create items in unit tests and business logic

Each source has different needs, but you have **one constructor** that tries to handle everything. This creates problems:

```csharp
public InventoryItem(string sku, string location, int quantity, DateTime receivedDate)
{
    // Validation
    if (string.IsNullOrEmpty(sku)) throw new ArgumentException(nameof(sku));
    if (quantity < 0) throw new ArgumentException(nameof(quantity));
    
    // Initialization
    SKU = sku;
    Location = location;
    Quantity = quantity;
    ReceivedDate = receivedDate;
    
    // Computed properties
    Status = quantity > 0 ? "In Stock" : "Out of Stock";
    LastUpdated = DateTime.UtcNow;
}
```

**Issues**:
- ‚ùå EF Core can't bypass validation when loading from database (trusted data)
- ‚ùå JSON deserializers struggle with required constructor parameters
- ‚ùå Source generators must emit validation code they didn't write
- ‚ùå Unit tests can't create test objects with invalid data for negative test cases

## The Old Approach (C# 13)

You had to create multiple constructors or factory methods:

```csharp
// Constructor 1: For manual creation (with validation)
public InventoryItem(string sku, string location, int quantity, DateTime receivedDate)
{
    ValidateAndInitialize(sku, location, quantity, receivedDate);
}

// Constructor 2: For EF Core (no validation)
internal InventoryItem() { }  // ‚Üê Confusing! Why is this empty?

// Constructor 3: For JSON deserialization
[JsonConstructor]
public InventoryItem(string sku, string location, int quantity) 
{
    // Partial initialization, validation happens elsewhere
}

// Helper method (duplicated logic)
private void ValidateAndInitialize(string sku, string location, int quantity, DateTime receivedDate)
{
    // Same validation code repeated across constructors
}
```

**Problems**:
- üî¥ Multiple constructors doing similar things
- üî¥ Validation logic duplicated or bypassed
- üî¥ Hard to understand which constructor to use
- üî¥ Attributes like `[JsonConstructor]` create tight coupling

## The C# 14 Solution: Partial Constructors

Partial constructors let you **layer initialization** cleanly:

```csharp
public partial class InventoryItem
{
    // Step 1: Always runs (sets properties)
    public partial void Initialize(string sku, string location, int quantity, DateTime receivedDate);
    
    // Step 2: Optional (validates properties)
    public partial void Validate();
    
    // Main constructor: Orchestrates the steps
    public InventoryItem(string sku, string location, int quantity, DateTime receivedDate)
    {
        Initialize(sku, location, quantity, receivedDate);  // ‚Üê Always set properties
        Validate();                                          // ‚Üê Then validate
    }
}

// Implementation (can be in another file or generated by source generator)
public partial class InventoryItem
{
    public partial void Initialize(string sku, string location, int quantity, DateTime receivedDate)
    {
        SKU = sku;
        Location = location;
        Quantity = quantity;
        ReceivedDate = receivedDate;
    }
    
    public partial void Validate()
    {
        if (string.IsNullOrEmpty(SKU)) throw new ArgumentException(nameof(SKU));
        if (Quantity < 0) throw new ArgumentException(nameof(Quantity));
    }
}
```

**Why this matters**:
- ‚úÖ **Clear separation**: Initialization ‚â† Validation
- ‚úÖ **Composable**: Call just `Initialize()` when loading from database
- ‚úÖ **Source-gen friendly**: Generator can implement `Initialize()`, you write `Validate()`
- ‚úÖ **Testable**: Create invalid objects for negative tests by skipping `Validate()`

## Real-World Example: Meijer's Inventory Service

**Before** (C# 13 - multiple constructors):
```csharp
// Manual creation
var item1 = new InventoryItem("SKU123", "Warehouse-A", 50, DateTime.UtcNow);  // ‚úì Validated

// EF Core loading
var item2 = new InventoryItem();  // ‚Üê Empty constructor, sets properties later
// ‚úó No validation! Corrupt data from DB passes through

// Unit test (trying to test error handling)
// Can't create invalid item because constructor throws!
```

**After** (C# 14 - partial constructors):
```csharp
// Manual creation
var item1 = new InventoryItem("SKU123", "Warehouse-A", 50, DateTime.UtcNow);  // ‚úì Full construction

// EF Core loading (just initialization, skip validation for trusted DB data)
var item2 = new InventoryItem();
item2.Initialize("SKU456", "Warehouse-B", 100, DateTime.UtcNow);  // ‚úì Properties set

// Unit test (test error handling with invalid data)
var item3 = new InventoryItem();
item3.Initialize("", "Warehouse-C", -10, DateTime.UtcNow);  // ‚úì Create invalid object
Assert.Throws<ArgumentException>(() => item3.Validate());   // ‚úì Validate separately
```

This means:
- **Flexible Loading**: EF Core and JSON deserializers can bypass validation
- **Better Testing**: Create invalid objects to test error scenarios
- **Source Generator Support**: Generated code handles initialization, your code handles validation
- **Single Responsibility**: Each method does one thing well

## Why This Matters for Customers

1. **Works with ORMs**: EF Core and Dapper can materialize objects efficiently without forcing validation
2. **Enables Code Generation**: Source generators can implement `Initialize()` based on database schema, you focus on business rules in `Validate()`
3. **Better Unit Tests**: Test error handling by creating objects in invalid states
4. **Performance**: Skip validation for trusted data sources (database, internal services) while enforcing it for untrusted sources (user input, external APIs)

---

## "But We Already Do This!" - Addressing Common Pushback

### Pushback #1: "We use parameterless constructors for EF Core"

**You might say**: "We already have a parameterless constructor for EF Core:"

```csharp
public class InventoryItem
{
    // EF Core constructor
    public InventoryItem() { }
    
    // User constructor
    public InventoryItem(string sku, string location, int quantity, DateTime receivedDate)
    {
        SKU = sku;
        Location = location;
        Quantity = quantity;
        ReceivedDate = receivedDate;
    }
    
    public string SKU { get; set; }
    public string Location { get; set; }
    public int Quantity { get; set; }
    public DateTime ReceivedDate { get; set; }
}
```

**Response**: This works, but creates confusion and allows invalid objects:

**Problems**:
```csharp
// Problem 1: Anyone can create empty objects
var item = new InventoryItem();  // ‚Üê All properties null/default!
// item.SKU is null, item.Quantity is 0
// Object is in invalid state, but no exception thrown

// Problem 2: No clear initialization contract
item.SKU = "SKU123";  // Set properties manually... which ones are required?
item.Location = "Warehouse-A";  // Is this order correct?
// Missing Quantity and ReceivedDate - still invalid!

// Problem 3: EF Core and manual creation use same constructor
// No way to distinguish "loading from trusted DB" vs "creating from untrusted input"
```

**Partial constructors make intent explicit**:
```csharp
public partial class InventoryItem
{
    // For EF Core: Sets properties, no validation
    public partial void Initialize(string sku, string location, int quantity, DateTime receivedDate);
    
    // For validation: Only called when needed
    public partial void Validate();
    
    // For manual creation: Initialize + Validate
    public InventoryItem(string sku, string location, int quantity, DateTime receivedDate)
    {
        Initialize(sku, location, quantity, receivedDate);
        Validate();
    }
    
    // For EF Core: Initialize only
    internal InventoryItem() { }  // EF Core calls Initialize() after construction
}
```

**Benefits**:
- ‚úÖ Clear contract: `Initialize()` always sets all required properties
- ‚úÖ Intentional skipping: EF Core can skip `Validate()` for trusted data
- ‚úÖ Prevents misuse: Parameterless constructor is `internal`, not public

### Pushback #2: "We use factory methods"

**You might say**: "We use factory methods for different creation scenarios:"

```csharp
public class InventoryItem
{
    // Private constructor prevents direct instantiation
    private InventoryItem() { }
    
    // Factory for manual creation
    public static InventoryItem Create(string sku, string location, int quantity, DateTime receivedDate)
    {
        var item = new InventoryItem();
        // Validation + initialization
        if (string.IsNullOrEmpty(sku)) throw new ArgumentException();
        item.SKU = sku;
        item.Location = location;
        item.Quantity = quantity;
        item.ReceivedDate = receivedDate;
        return item;
    }
    
    // Factory for EF Core
    public static InventoryItem FromDatabase(string sku, string location, int quantity, DateTime receivedDate)
    {
        var item = new InventoryItem();
        // No validation - trusted data
        item.SKU = sku;
        item.Location = location;
        item.Quantity = quantity;
        item.ReceivedDate = receivedDate;
        return item;
    }
}
```

**Response**: Factory methods work, but don't compose well with frameworks:

**Problems with Factory Methods**:
- ‚ùå EF Core can't call custom factory methods (requires constructor)
- ‚ùå JSON deserializers (System.Text.Json, Newtonsoft) expect constructors
- ‚ùå Source generators emit constructors, not factory methods
- ‚ùå Duplicated initialization code across factories

**Partial constructors work with all frameworks**:
```csharp
public partial class InventoryItem
{
    public partial void Initialize(string sku, string location, int quantity, DateTime receivedDate);
    public partial void Validate();
    
    // Works with manual creation
    public InventoryItem(string sku, string location, int quantity, DateTime receivedDate)
    {
        Initialize(sku, location, quantity, receivedDate);
        Validate();
    }
    
    // Works with EF Core
    internal InventoryItem() { }  // EF Core calls Initialize()
    
    // Works with JSON (attribute points to partial constructor)
    [JsonConstructor]
    public InventoryItem(string sku, string location) 
    {
        Initialize(sku, location, 0, DateTime.UtcNow);
    }
}
```

**When to use each**:
- **Factory Methods**: Complex object creation with multiple steps, caching, or pooling
- **Partial Constructors**: Framework interop (EF Core, JSON, source generators)

### Pushback #3: "We use builder pattern"

**You might say**: "We use the builder pattern for complex initialization:"

```csharp
public class InventoryItemBuilder
{
    private string _sku;
    private string _location;
    private int _quantity;
    private DateTime _receivedDate;
    
    public InventoryItemBuilder WithSKU(string sku) { _sku = sku; return this; }
    public InventoryItemBuilder WithLocation(string location) { _location = location; return this; }
    public InventoryItemBuilder WithQuantity(int quantity) { _quantity = quantity; return this; }
    public InventoryItemBuilder ReceivedOn(DateTime date) { _receivedDate = date; return this; }
    
    public InventoryItem Build()
    {
        // Validation + construction
        if (string.IsNullOrEmpty(_sku)) throw new ArgumentException();
        return new InventoryItem(_sku, _location, _quantity, _receivedDate);
    }
}

// Usage:
var item = new InventoryItemBuilder()
    .WithSKU("SKU123")
    .WithLocation("Warehouse-A")
    .WithQuantity(50)
    .ReceivedOn(DateTime.UtcNow)
    .Build();
```

**Response**: Builders are great for complex objects with many optional parameters, but overkill for simple cases:

**When Builders Make Sense**:
- ‚úÖ 10+ properties with many optional
- ‚úÖ Complex validation rules across multiple properties
- ‚úÖ Need to construct object incrementally over time

**When Builders Are Overkill**:
- ‚ùå Simple objects with 3-5 required properties
- ‚ùå All properties are required (no optional parameters)
- ‚ùå Framework integration needed (EF Core, JSON, source generators can't use builders)

**Real Example from Meijer**:
```csharp
// InventoryItem has 4 required properties - builder is verbose:
var item = new InventoryItemBuilder()
    .WithSKU("SKU123")              // ‚Üê 5 lines of code
    .WithLocation("Warehouse-A")
    .WithQuantity(50)
    .ReceivedOn(DateTime.UtcNow)
    .Build();

// Partial constructor is simpler:
var item = new InventoryItem("SKU123", "Warehouse-A", 50, DateTime.UtcNow);  // ‚Üê 1 line
```

**Best Practice**: Use builders for **optional parameters**, partial constructors for **required parameters**:
```csharp
public partial class InventoryItem
{
    // Required properties via partial constructor
    public partial void Initialize(string sku, string location, int quantity, DateTime receivedDate);
    
    // Optional properties via builder-style methods
    public InventoryItem WithNotes(string notes) { Notes = notes; return this; }
    public InventoryItem WithTags(params string[] tags) { Tags = tags; return this; }
}

// Best of both:
var item = new InventoryItem("SKU123", "Warehouse-A", 50, DateTime.UtcNow)
    .WithNotes("Handle with care")
    .WithTags("fragile", "perishable");
```

### Pushback #4: "We use source generators to create constructors"

**You might say**: "We use source generators (like JsonSourceGenerator) to auto-generate constructors:"

```csharp
[JsonSerializable(typeof(InventoryItem))]
public partial class InventoryItemContext : JsonSerializerContext { }

// Generator creates constructor automatically
public partial class InventoryItem
{
    public string SKU { get; set; }
    public string Location { get; set; }
}
```

**Response**: You're already using partial classes! Partial constructors **extend** this pattern:

**The Problem with Generated-Only Constructors**:
```csharp
// Generator creates:
public partial class InventoryItem
{
    public InventoryItem(string sku, string location) 
    {
        SKU = sku;
        Location = location;
    }
}

// But you can't add validation without modifying generated code!
// If you add another partial constructor, you get compiler error (duplicate constructors)
```

**Partial constructors solve this**:
```csharp
// Generator creates Initialize() instead of constructor:
[GeneratedInitialize]
public partial class InventoryItem
{
    public partial void Initialize(string sku, string location, int quantity, DateTime receivedDate)
    {
        SKU = sku;
        Location = location;
        Quantity = quantity;
        ReceivedDate = receivedDate;
    }
}

// You add validation in your code:
public partial class InventoryItem
{
    public partial void Validate()
    {
        if (string.IsNullOrEmpty(SKU)) throw new ArgumentException();
        if (Quantity < 0) throw new ArgumentException();
    }
    
    // Orchestrate: Initialize + Validate
    public InventoryItem(string sku, string location, int quantity, DateTime receivedDate)
    {
        Initialize(sku, location, quantity, receivedDate);  // ‚Üê Generated code
        Validate();                                          // ‚Üê Your code
    }
}
```

**Why this matters**:
- ‚úÖ Generator focuses on initialization (property setting)
- ‚úÖ You focus on validation (business rules)
- ‚úÖ No conflicts: One `Initialize()` method, one constructor
- ‚úÖ Composable: Mix generated and manual code cleanly

### Pushback #5: "We use init-only properties with required keyword"

**You might say**: "We use C# 11's `required` keyword with `init` properties:"

```csharp
public class InventoryItem
{
    public required string SKU { get; init; }
    public required string Location { get; init; }
    public required int Quantity { get; init; }
    public required DateTime ReceivedDate { get; init; }
}

// Usage:
var item = new InventoryItem 
{
    SKU = "SKU123",
    Location = "Warehouse-A",
    Quantity = 50,
    ReceivedDate = DateTime.UtcNow
};
```

**Response**: `required` properties work great for simple cases, but have limitations:

**When `required` Works Well**:
- ‚úÖ Simple DTOs or data classes
- ‚úÖ All properties are primitive types
- ‚úÖ No validation logic needed at construction
- ‚úÖ Object initializer syntax is acceptable

**Limitations of `required`**:
- ‚ùå **No validation during construction**: Properties are set one at a time, object briefly exists in invalid state
  ```csharp
  var item = new InventoryItem 
  {
      SKU = "SKU123",
      Location = "Warehouse-A",
      Quantity = -50,  // ‚Üê Invalid! But no error yet
      ReceivedDate = DateTime.UtcNow
  };  // ‚Üê Validation can only happen after construction completes
  ```

- ‚ùå **No computed properties**: Can't calculate derived values during initialization
  ```csharp
  // Can't do this with init properties:
  public string Status { get; init; }  // Needs to be computed from Quantity
  ```

- ‚ùå **Verbose for many properties**: Object initializer syntax becomes unwieldy with 10+ properties

- ‚ùå **EF Core complications**: `init` properties require special configuration for change tracking

**Partial constructors complement `required` properties**:
```csharp
public partial class InventoryItem
{
    public required string SKU { get; init; }
    public required string Location { get; init; }
    public required int Quantity { get; init; }
    public required DateTime ReceivedDate { get; init; }
    
    // Computed property
    public string Status { get; private set; }
    
    // Partial constructor: Initialize computed properties + validate
    public partial void Initialize(string sku, string location, int quantity, DateTime receivedDate);
    public partial void Validate();
    
    [SetsRequiredMembers]  // ‚Üê Tells compiler constructor sets required properties
    public InventoryItem(string sku, string location, int quantity, DateTime receivedDate)
    {
        Initialize(sku, location, quantity, receivedDate);
        Status = quantity > 0 ? "In Stock" : "Out of Stock";  // ‚Üê Compute derived value
        Validate();  // ‚Üê Validate everything at once
    }
}
```

**Best Practice**: 
- Use `required` for simple data classes (DTOs, API models)
- Use partial constructors for domain models with validation and computed properties

---

## Summary: Why C# 14 Partial Constructors Matter

**What enterprises do today**:
1. Multiple constructors (confusing, duplicated code)
2. Factory methods (don't work with EF Core/JSON)
3. Builder pattern (overkill for simple objects)
4. Source generators (hard to add validation)
5. `required` properties (no validation during construction)

**What C# 14 partial constructors provide**:
- ‚úÖ **Layered initialization**: Separate property setting from validation
- ‚úÖ **Framework friendly**: Works with EF Core, JSON, source generators
- ‚úÖ **Composable**: Mix generated and manual code
- ‚úÖ **Testable**: Create invalid objects for negative tests
- ‚úÖ **Single responsibility**: Each method does one thing

**Perfect for**:
- Domain models loaded by ORMs
- Objects created by source generators
- Classes that need validation at construction
- Code shared across multiple initialization paths

**Best of all**: You can **compose** initialization, validation, and computation cleanly‚Äîwithout framework conflicts.
