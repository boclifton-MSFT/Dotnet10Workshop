# Feature 3: Partial Constructors

## Run It

```powershell
dotnet run -f net10.0
```

## The Business Problem

Meijer's inventory system needs flexibility in how `InventoryItem` objects are constructed, especially when working with:

- **Source Generators**: Auto-generate constructor signatures based on database schemas or API contracts
- **Platform Bindings**: Interop scenarios where framework code generates constructor stubs
- **Code Separation**: Teams want to separate generated initialization code from manual validation logic
- **Layered Architecture**: Different teams or tools contribute to different parts of object construction

The challenge: How do you split constructor logic across generated and manual code without conflicts?

## The Old Approach (C# 13)

Before C# 14, you couldn't split a constructor's signature and implementation across partial class parts:

```csharp
// File 1: MyClass.Generated.cs (auto-generated)
public partial class InventoryItem
{
    // Can't declare just a constructor signature!
    // Must have a full constructor or none at all
    public InventoryItem(string sku, int qty)
    {
        SKU = sku;
        Quantity = qty;
    }
}

// File 2: MyClass.cs (manual code)
public partial class InventoryItem
{
    // Can't add constructor body here - would be duplicate!
    // Forced to use workarounds like Init methods
    public void Initialize()
    {
        // Validation logic here
        if (Quantity < 0) throw new ArgumentException();
    }
}
```

**Problems**:
- üî¥ Can't separate constructor signature from implementation
- üî¥ Source generators must emit complete constructors (including validation)
- üî¥ Manual code forced to use initialization methods instead of constructors
- üî¥ Merge conflicts when multiple tools generate constructors

## The C# 14 Solution: Partial Constructors

C# 14 lets you **split constructor declaration and implementation** across partial class parts:

```csharp
// File 1: InventoryItem.Generated.cs (auto-generated by tool)
public partial class InventoryItem
{
    // Defining declaration: Just the signature, no body
    // Source generator declares this based on schema
    public partial InventoryItem(string sku, string location, int quantity, DateTime receivedDate);
}

// File 2: InventoryItem.cs (manual code)
public partial class InventoryItem
{
    // Implementing declaration: Provides the constructor body
    // Your team writes the initialization and validation logic
    public partial InventoryItem(string sku, string location, int quantity, DateTime receivedDate)
    {
        SKU = sku;
        Location = location;
        Quantity = quantity;
        ReceivedDate = receivedDate;
        
        if (string.IsNullOrEmpty(SKU)) throw new ArgumentException(nameof(SKU));
        if (Quantity < 0) throw new ArgumentException(nameof(Quantity));
    }
}
```

**Key Rules**:
- ‚úÖ **One defining, one implementing**: Exactly one signature declaration, one implementation
- ‚úÖ **Same signature**: Parameters must match exactly between declaration and implementation
- ‚úÖ **Partial class required**: Both parts must be in a partial class
- ‚úÖ **Constructor initializer**: Only implementing part can have `: base()` or `: this()`

**Why this matters**:
- ‚úÖ **Code generation friendly**: Source generators declare, you implement (or vice versa)
- ‚úÖ **Clear separation**: Framework bindings vs. custom logic
- ‚úÖ **No conflicts**: One signature + one body = no duplicate constructor errors
- ‚úÖ **Flexible ownership**: Different teams/tools own different parts

## Real-World Example: Meijer's Inventory Service with Source Generator

**Scenario**: A source generator analyzes your database schema and generates constructor signatures for all entity classes.

**Generated Code** (InventoryItem.Generated.cs):
```csharp
// This file is auto-generated from database schema
// DO NOT EDIT - Changes will be overwritten

public partial class InventoryItem
{
    public string SKU { get; set; }
    public string Location { get; set; }
    public int Quantity { get; set; }
    public DateTime ReceivedDate { get; set; }
    
    // Generator declares constructor signature based on schema
    public partial InventoryItem(string sku, string location, int quantity, DateTime receivedDate);
}
```

**Manual Code** (InventoryItem.cs):
```csharp
// Your business logic - add validation, computed properties, etc.

public partial class InventoryItem
{
    public string Status { get; private set; }
    
    // Implement the constructor declared by generator
    public partial InventoryItem(string sku, string location, int quantity, DateTime receivedDate)
    {
        // Set properties from parameters
        SKU = sku;
        Location = location;
        Quantity = quantity;
        ReceivedDate = receivedDate;
        
        // Add business validation
        if (string.IsNullOrEmpty(SKU))
            throw new ArgumentException("SKU is required", nameof(SKU));
        if (Quantity < 0)
            throw new ArgumentException("Quantity cannot be negative", nameof(Quantity));
        
        // Compute derived properties
        Status = Quantity > 0 ? "In Stock" : "Out of Stock";
    }
}
```

**Benefits**:
- ‚úÖ **Generator stays simple**: Only needs to emit signature based on schema
- ‚úÖ **You own logic**: Business rules and validation in your code
- ‚úÖ **No conflicts**: Schema changes regenerate signature, your implementation stays separate
- ‚úÖ **Single constructor**: No ambiguity about which constructor to use

## Real-World Example: Platform Interop Bindings

**Scenario**: Xamarin/MAUI platform bindings where framework generates native wrapper stubs.

**Platform-Generated Code** (AVAudioCompressedBuffer.g.cs):
```csharp
// Auto-generated by platform binding generator
namespace AVFoundation 
{
    public partial class AVAudioCompressedBuffer : AVAudioBuffer
    {
        // Platform declares constructor for native interop
        public partial AVAudioCompressedBuffer(AVAudioFormat format, uint packetCapacity);
    }
}
```

**Developer Implementation** (AVAudioCompressedBuffer.cs):
```csharp
// Developer provides native initialization logic
namespace AVFoundation 
{
    public partial class AVAudioCompressedBuffer : AVAudioBuffer
    {
        // Implement with platform-specific base class initialization
        public partial AVAudioCompressedBuffer(AVAudioFormat format, uint packetCapacity)
            : base(NSObjectFlag.Empty)  // ‚Üê Only implementing part can have base()
        {
            // Native handle initialization
            Handle = InitNative(format, packetCapacity);
        }
        
        private IntPtr InitNative(AVAudioFormat format, uint packetCapacity)
        {
            // Platform-specific native code
            return /* ... */;
        }
    }
}
```

## Comparison with Other Patterns

### vs. Partial Methods
**Partial Methods** (C# 3.0+): Split method signature and implementation
```csharp
partial class MyClass
{
    partial void OnCreated();  // ‚Üê Declaration (optional to implement)
}
partial class MyClass
{
    partial void OnCreated() { /* ... */ }  // ‚Üê Implementation (optional)
}
```

**Partial Constructors** (C# 14): Split constructor signature and implementation
```csharp
partial class MyClass
{
    public partial MyClass(int value);  // ‚Üê Declaration (required)
}
partial class MyClass
{
    public partial MyClass(int value) { /* ... */ }  // ‚Üê Implementation (required)
}
```

**Key Differences**:
- Partial methods can be left unimplemented; partial constructors must be implemented
- Partial methods are typically `void` returning; constructors create instances
- Both enable code generation scenarios, but for different purposes

### vs. Factory Methods
**Factory Methods** work for custom creation logic but don't integrate with frameworks:
```csharp
public static InventoryItem Create(string sku, int qty)
{
    // Custom logic
    return new InventoryItem { SKU = sku, Quantity = qty };
}
```

**Partial Constructors** work with all frameworks (EF Core, JSON, source generators):
```csharp
public partial InventoryItem(string sku, int qty);  // ‚Üê Frameworks can use this
```

### vs. Builder Pattern
**Builder** is for optional parameters and incremental construction:
```csharp
new InventoryItemBuilder()
    .WithSKU("SKU-001")
    .WithQuantity(50)
    .Build();
```

**Partial Constructors** are for splitting ownership of required construction logic:
```csharp
public partial InventoryItem(string sku, int qty);  // ‚Üê Generator declares
public partial InventoryItem(string sku, int qty) { /* ... */ }  // ‚Üê You implement
```

## Why This Matters for Customers

1. **Source Generator Support**: Generators emit constructor signatures, you add business logic
2. **Platform Interop**: Framework bindings declare constructors, you implement platform-specific initialization
3. **Team Collaboration**: Generated code and manual code coexist without conflicts
4. **Schema Evolution**: Database schema changes regenerate signatures without touching your logic
5. **Clear Ownership**: Explicit separation of what's generated vs. what's custom

---

## Common Questions

### Q: When should I use partial constructors?

**Use partial constructors when**:
- ‚úÖ Working with source generators that create constructor signatures
- ‚úÖ Building platform bindings or interop layers
- ‚úÖ Different teams/tools need to contribute to constructor logic
- ‚úÖ Schema-driven development where constructors map to data contracts

**Don't use partial constructors for**:
- ‚ùå Simple classes where one constructor does everything
- ‚ùå Validation-only scenarios (just use regular constructors)
- ‚ùå When factory methods or builders are more appropriate

### Q: Can I have multiple partial constructors?

Yes, you can have multiple constructors, but each must have a unique signature:

```csharp
partial class InventoryItem
{
    public partial InventoryItem(string sku, int qty);  // ‚Üê Constructor 1
    public partial InventoryItem(string sku);            // ‚Üê Constructor 2
}

partial class InventoryItem
{
    public partial InventoryItem(string sku, int qty) { /* ... */ }
    public partial InventoryItem(string sku) { /* ... */ }
}
```

### Q: What about constructor initializers (`: base()` or `: this()`)?

Only the **implementing declaration** can have constructor initializers:

```csharp
partial class DerivedItem : InventoryItem
{
    public partial DerivedItem(string sku, int qty);  // ‚Üê No initializer here
}

partial class DerivedItem : InventoryItem
{
    // Initializer goes on implementing declaration
    public partial DerivedItem(string sku, int qty) : base(sku, qty)  // ‚Üê ‚úÖ Here
    {
        // Constructor body
    }
}
```

### Q: Do both parts need to have the same access modifier?

Yes, both defining and implementing declarations must have identical signatures including access modifiers:

```csharp
partial class InventoryItem
{
    public partial InventoryItem(string sku);  // ‚Üê Must be 'public' here
}

partial class InventoryItem
{
    public partial InventoryItem(string sku)   // ‚Üê And 'public' here
    {
        SKU = sku;
    }
}
```

### Q: How do partial constructors relate to required properties (C# 11)?

They work together! Use `[SetsRequiredMembers]` to indicate constructor sets required properties:

```csharp
partial class InventoryItem
{
    public required string SKU { get; init; }
    public required int Quantity { get; init; }
    
    [SetsRequiredMembers]  // ‚Üê Tells compiler constructor handles required props
    public partial InventoryItem(string sku, int qty);
}

partial class InventoryItem
{
    [SetsRequiredMembers]
    public partial InventoryItem(string sku, int qty)
    {
        SKU = sku;
        Quantity = qty;
    }
}
```

---

## Summary: C# 14 Partial Constructors

**What they are**:
- Split constructor declaration and implementation across partial class parts
- One part declares signature, another provides body
- Both parts must be in same partial class

**Primary use cases**:
- Source generators creating constructor signatures from schemas/contracts
- Platform bindings where framework generates stubs
- Code separation between generated and manual logic
- Team collaboration on constructor implementation

**Key benefits**:
- ‚úÖ No constructor duplication conflicts
- ‚úÖ Clean separation of generated vs. manual code
- ‚úÖ Works seamlessly with source generators
- ‚úÖ Enables layered architecture for object construction

**Remember**: Partial constructors are about **splitting ownership** of constructor logic, not about validation or initialization patterns (that's what partial methods are for).
